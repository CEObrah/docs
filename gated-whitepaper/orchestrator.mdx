---
title: "4. Orchestrator: Runtime Mixture-of-Experts"
description: "The Orchestrator is MindLab’s runtime Mixture-of-Experts engine. It acts as the brain of the system—deciding who does what, when and how."
---

## 4.1 Overview

The Orchestrator is MindLab’s runtime Mixture-of-Experts engine. It receives a validated CADANCE™ spec and user intent (e.g., via natural language or API), factorizes the objective into atomic tasks, selects the best expert for each task and coordinates execution through the Flow Engine. It acts as the brain of the system—deciding who does what, when and how.

## 4.2 Design Rationale

Traditional AI systems often rely on monolithic architectures: one model processes the entire input. This approach is brittle, lacks specialization and provides minimal control over intermediate steps. MindLab instead embraces runtime MoE. Instead of training a single massive sparse model, we compose multiple smaller agents at runtime. Benefits include:

- **Specialization:** Each agent can be optimized for a specific domain or task.
- **Flexibility:** Agents can be added, removed or swapped without retraining a giant model.
- **Policy Control:** The orchestrator enforces budgets, gates and fallback strategies at runtime.

In essence, training-time MoE concentrates parameters; MindLab’s runtime MoE concentrates workflow logic and control.

## 4.3 Mechanism and Algorithms

### 4.3.1 Task Factorization

Upon receiving a request, the orchestrator consults the CADANCE™ spec’s Config and uses a Planner agent to decompose the objective into a directed acyclic graph (DAG) or state machine.

### 4.3.2 Expert Selection & Routing

For each node, the orchestrator queries the Expert Registry to find candidate agents. It evaluates them on: skill match, confidence, cost/latency envelope, policy compliance, and load discipline.

### 4.3.3 Topologies and Patterns

MindLab provides reusable topologies such as Planner→Solver→Reviewer→Verifier.

### 4.3.4 Late Binding and Re-routing

Unlike static pipelines, the orchestrator binds agents just in time. If a solver fails, times out or produces a low-quality output, the orchestrator re-routes the task to an alternative agent (fallback) or escalates to a human reviewer.

## 4.4 Interfaces & APIs

The orchestrator exposes a JSON/HTTP API and a natural-language interface:

- `POST /v1/intent` – Accepts user intent and optional CADANCE™ spec override.
- `GET /v1/run/<id>` – Retrieves the current status, intermediate results or final output.
- **WebSocket streaming** – Streams intermediate outputs to clients for interactive experiences.

## 4.5 Failure Modes & Mitigations

- **Routing Failure:** No agent meets constraints. Mitigation: return a clear error and optionally degrade gracefully.
- **Execution Failure:** Agent fails or times out. Mitigation: automatic retry with exponential backoff; re-route to another agent.
- **Policy Violation:** Agent attempts an unauthorized action. Mitigation: gating through Norms; abort and alert.

## 4.6 Metrics & SLOs

- **Routing Time:** < [METRIC_PLACEHOLDER] ms per node.
- **First-Call Success Rate:** > [METRIC_PLACEHOLDER] % (fraction of tasks solved without retries).
- **Fallback Rate:** Fraction of tasks requiring re-routing or human escalation.

## 4.7 Key Takeaways

- The orchestrator replaces monolithic, opaque models with a dynamic mixture of specialist agents.
- It performs task factorization, agent selection, topology execution and re-routing at runtime.
- Late binding and fallback strategies provide resiliency and allow rapid adoption of new experts.